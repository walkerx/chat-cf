# Data Model: AI Chat (Streaming)

**Feature**: AI Chat with streaming output | **Date**: 2025-11-14
**Purpose**: Define entity types, relationships, and database schema for conversation persistence.

---

## Entity Overview

The AI chat feature requires four primary entities:

1. **ClientSession**: Tracks anonymous users via session ID
2. **Conversation**: Represents a multi-turn chat session with an AI
3. **Message**: Individual messages within a conversation (user or assistant)
4. **StreamChunk**: Represents a single chunk of streamed AI response (ephemeral, not persisted)

```
ClientSession (1) ──────< (N) Conversation
                              │
                              ├─────< (N) Message
                              │
                              └─ [related: StreamChunk] (ephemeral)
```

---

## Entity Definitions

### 1. ClientSession

**Purpose**: Track anonymous users and their session lifecycle.

**Fields**:

| Field | Type | Nullable | Unique | Description |
|-------|------|----------|--------|-------------|
| `id` | UUID (TEXT) | No | Yes | Session identifier; generated client-side or server-side on first request |
| `created_at` | ISO 8601 (TEXT) | No | No | UTC timestamp when session was created |
| `last_activity` | ISO 8601 (TEXT) | No | No | UTC timestamp of last API request (used for cleanup) |
| `metadata` | JSON (TEXT) | Yes | No | Optional: user agent, IP hash, browser info (for analytics) |

**Constraints**:

- PRIMARY KEY: `id`
- CHECK: `created_at <= last_activity` (temporal consistency)
- INDEX: `last_activity DESC` (for session cleanup queries)

**Example**:
```json
{
  "id": "550e8400-e29b-41d4-a716-446655440000",
  "created_at": "2025-11-14T10:30:00Z",
  "last_activity": "2025-11-14T10:45:30Z",
  "metadata": { "userAgent": "Mozilla/5.0...", "ipHash": "abc123" }
}
```

**Lifecycle**:

- Created: On first request to `/api/chat/stream` (if session ID not in header)
- Updated: `last_activity` bumped on every API call
- Deleted: After 30 days of inactivity (background cleanup job, Phase 2)

---

### 2. Conversation

**Purpose**: Group related messages into a multi-turn chat session.

**Fields**:

| Field | Type | Nullable | Unique | Description |
|-------|------|----------|--------|-------------|
| `id` | UUID (TEXT) | No | Yes | Conversation identifier; generated by server |
| `session_id` | UUID (TEXT) | No | No | Foreign key to ClientSession; identifies the user |
| `title` | TEXT | Yes | No | Auto-inferred conversation title (e.g., "Questions about Python") |
| `created_at` | ISO 8601 (TEXT) | No | No | UTC timestamp when conversation started |
| `updated_at` | ISO 8601 (TEXT) | No | No | UTC timestamp of last message (used for sorting) |

**Constraints**:

- PRIMARY KEY: `id`
- FOREIGN KEY: `session_id` → `ClientSession.id` (ON DELETE CASCADE)
- CHECK: `created_at <= updated_at`
- INDEX: `(session_id, updated_at DESC)` (for listing user's recent conversations)
- INDEX: `updated_at DESC` (for "latest conversations" queries)

**Example**:
```json
{
  "id": "conv-660e9400-e29b-41d4-a716-446655440111",
  "session_id": "550e8400-e29b-41d4-a716-446655440000",
  "title": "Python debugging tips",
  "created_at": "2025-11-14T10:30:00Z",
  "updated_at": "2025-11-14T10:45:30Z"
}
```

**Lifecycle**:

- Created: Explicit `POST /api/conversations` or implicit on first message in new conversation
- Updated: `updated_at` changes when a new Message is added
- Deleted: User request or with parent ClientSession (cascade)
- Listed: `GET /api/conversations?sessionId=...` ordered by `updated_at DESC`

---

### 3. Message

**Purpose**: Store individual messages (user prompts and assistant responses).

**Fields**:

| Field | Type | Nullable | Unique | Description |
|-------|------|----------|--------|-------------|
| `id` | UUID (TEXT) | No | Yes | Message identifier; generated by server |
| `conversation_id` | UUID (TEXT) | No | No | Foreign key to Conversation; links message to a chat session |
| `role` | TEXT (ENUM) | No | No | Either `'user'` or `'assistant'` |
| `content` | TEXT | No | No | Full message text (user prompt or assistant response) |
| `created_at` | ISO 8601 (TEXT) | No | No | UTC timestamp when message was created |

**Constraints**:

- PRIMARY KEY: `id`
- FOREIGN KEY: `conversation_id` → `Conversation.id` (ON DELETE CASCADE)
- CHECK: `role IN ('user', 'assistant')`
- INDEX: `(conversation_id, created_at ASC)` (for loading conversation history)
- UNIQUE: None (same user prompt can be asked multiple times)

**Example** (user message):
```json
{
  "id": "msg-770e9400-e29b-41d4-a716-446655440222",
  "conversation_id": "conv-660e9400-e29b-41d4-a716-446655440111",
  "role": "user",
  "content": "How do I debug a Python memory leak?",
  "created_at": "2025-11-14T10:30:05Z"
}
```

**Example** (assistant message):
```json
{
  "id": "msg-770e9400-e29b-41d4-a716-446655440333",
  "conversation_id": "conv-660e9400-e29b-41d4-a716-446655440111",
  "role": "assistant",
  "content": "Memory leaks in Python typically occur when... [full response from Claude]",
  "created_at": "2025-11-14T10:30:35Z"
}
```

**Lifecycle**:

- Created: On user message submission (`POST /api/chat/stream`) or after streaming response completes
- Updated: Never (immutable once persisted)
- Deleted: With parent Conversation (cascade)
- Queried: `GET /api/conversations/{id}` loads all messages in conversation

---

### 4. StreamChunk (Ephemeral)

**Purpose**: Represent a single chunk of streamed response (NOT persisted; ephemeral during streaming).

**Fields**:

| Field | Type | Nullable | Description |
|-------|------|----------|-------------|
| `index` | Integer | No | Sequence number (0, 1, 2, ...) |
| `text` | TEXT | No | The partial response text from AI model |
| `type` | TEXT | No | Either `'content'` (text chunk) or `'error'` (error message) |
| `timestamp` | ISO 8601 (TEXT) | No | UTC timestamp when chunk was received |

**Constraints**:

- No persistence: Chunks are streamed directly to client via SSE and discarded
- Final assembly: Frontend combines chunks into complete Message after streaming ends
- Only after completion is a single Message record created with the full `content`

**Example** (streamed chunk):
```json
{
  "index": 0,
  "text": "Memory leaks in Python typically occur when objects are held in memory longer",
  "type": "content",
  "timestamp": "2025-11-14T10:30:35.100Z"
}
```

**Example** (error chunk):
```json
{
  "index": 1,
  "text": "API error: rate limit exceeded",
  "type": "error",
  "timestamp": "2025-11-14T10:30:36.200Z"
}
```

**Lifecycle**:

- Created: On each SSE `data:` event from `/api/chat/stream`
- Sent: Streamed immediately to client (no storage)
- Discarded: After streaming ends or on error
- After-streaming: Frontend collects all chunks, joins text, creates Message record

---

## Relationships

### ClientSession → Conversation (1:N)

- One ClientSession can have many Conversations
- Each Conversation belongs to exactly one ClientSession
- Deletion: Cascade (deleting a ClientSession deletes all its Conversations)

**Query Pattern**:
```sql
SELECT * FROM conversations
WHERE session_id = ? 
ORDER BY updated_at DESC
LIMIT 10;
```

### Conversation → Message (1:N)

- One Conversation contains many Messages
- Each Message belongs to exactly one Conversation
- Deletion: Cascade (deleting a Conversation deletes all its Messages)
- Ordering: Messages are always ordered by `created_at ASC` to preserve chat history

**Query Pattern**:
```sql
SELECT * FROM messages
WHERE conversation_id = ?
ORDER BY created_at ASC;
```

### Message (no direct reference to StreamChunk)

- StreamChunk is ephemeral and not persisted
- StreamChunks are transmitted via SSE during `/api/chat/stream` request
- After streaming completes, frontend assembles a complete Message and POSTs it back (or handler auto-saves)

---

## Data Type Reference

**UUID**: 
- Format: `xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx` (36 characters)
- Storage: TEXT in D1 (SQLite has no native UUID type)
- Generation: Client-side via `crypto.randomUUID()` or server-side via Hono/Wrangler utilities

**ISO 8601**:
- Format: `2025-11-14T10:30:00Z` (UTC, Z suffix mandatory)
- Storage: TEXT in D1
- Generation: `new Date().toISOString()` (JavaScript)

**JSON**:
- Storage: TEXT in D1 (parsed/serialized by application)
- Example: `{"userAgent": "Mozilla/5.0...", "ipHash": "abc123"}`

---

## Query Patterns

### Load Conversation History (for UI)

```sql
SELECT * FROM messages
WHERE conversation_id = ?
ORDER BY created_at ASC;
```

**Response**: Array of `{ id, role, content, created_at }`

### List User's Conversations

```sql
SELECT * FROM conversations
WHERE session_id = ?
ORDER BY updated_at DESC
LIMIT 10;
```

**Response**: Array of `{ id, title, updated_at, created_at }`

### Create New Conversation

```sql
INSERT INTO conversations (id, session_id, title, created_at, updated_at)
VALUES (?, ?, NULL, ?, ?);
```

**Returns**: New `Conversation` object

### Append Message to Conversation

```sql
INSERT INTO messages (id, conversation_id, role, content, created_at)
VALUES (?, ?, ?, ?, ?);

UPDATE conversations SET updated_at = ? WHERE id = ?;
```

**Returns**: New `Message` object + updated `Conversation.updated_at`

### Update Session Activity

```sql
UPDATE client_sessions SET last_activity = ? WHERE id = ?;
```

---

## Indexes Summary

**For Performance** (creation and update operations should maintain these):

| Table | Index Name | Columns | Purpose |
|-------|------------|---------|---------|
| `conversations` | `idx_conv_session_updated` | `(session_id, updated_at DESC)` | List user's recent conversations |
| `conversations` | `idx_conv_updated` | `updated_at DESC` | Global "latest conversations" query |
| `messages` | `idx_msg_conversation` | `(conversation_id, created_at ASC)` | Load conversation history |
| `client_sessions` | `idx_session_activity` | `last_activity DESC` | Cleanup expired sessions |

---

## Storage Estimates (MVP)

**Assumptions**:
- 100 concurrent users (max per spec)
- Each user has 3 conversations
- Each conversation has ~10 messages
- Average message: 300 characters

**Calculations**:

| Entity | Count | Avg Size | Total |
|--------|-------|----------|-------|
| `ClientSession` | 100 | 200 bytes | 20 KB |
| `Conversation` | 300 | 150 bytes | 45 KB |
| `Message` | 3,000 | 400 bytes | 1.2 MB |
| **Total** | | | **~1.3 MB** |

**D1 Quota**: Included free tier supports up to 1 GB, so well within budget for MVP.

---

## Evolution (Phase 2+)

**Potential extensions**:

1. **User Accounts**: Add `users` table with email/password; replace `ClientSession` with `user_id`
2. **Message Attachments**: Add `attachments` table with image/file references (currently text-only)
3. **Feedback/Ratings**: Add `message_feedback` table to collect user ratings on responses (for fine-tuning)
4. **Conversation Sharing**: Add `shared_conversations` table to track conversation shares (collaboration feature)
5. **Model Selection**: Add `model_name` field to `conversations` (track which AI model was used)

---

## Next Steps

- **contracts/database.sql**: DDL statements for D1 (CREATE TABLE, indexes)
- **contracts/api.openapi.yaml**: OpenAPI spec with request/response schemas using these entities
- **Implementation** (Phase 2): Hono handlers using D1 bindings to perform CRUD operations
